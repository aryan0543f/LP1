
import java.util.*;

class Process {

    int pid;            // Process ID
    int burstTime;      // Burst Time
    int arrivalTime;    // Arrival Time
    int priority;       // Priority
    int waitingTime;    // Waiting Time
    int turnaroundTime; // Turnaround Time
    int remainingTime;  // For Round Robin

    Process(int pid, int burstTime, int arrivalTime, int priority) {
        this.pid = pid;
        this.burstTime = burstTime;
        this.arrivalTime = arrivalTime;
        this.priority = priority;
        this.remainingTime = burstTime;
    }
}

public class CPUScheduling {

    // ---------- Priority (Non-Preemptive) Scheduling ----------
    public static void priorityNonPreemptive(List<Process> processes) {
        int n = processes.size();
        processes.sort(Comparator.comparingInt(p -> p.arrivalTime));
        int currentTime = 0;
        int completed = 0;
        boolean[] isCompleted = new boolean[n];

        while (completed != n) {
            int idx = -1;
            int highestPriority = Integer.MAX_VALUE;

            for (int i = 0; i < n; i++) {
                Process p = processes.get(i);
                if (p.arrivalTime <= currentTime && !isCompleted[i]) {
                    if (p.priority < highestPriority) {
                        highestPriority = p.priority;
                        idx = i;
                    }
                }
            }

            if (idx != -1) {
                Process p = processes.get(idx);
                p.waitingTime = currentTime - p.arrivalTime;
                currentTime += p.burstTime;
                p.turnaroundTime = p.waitingTime + p.burstTime;
                isCompleted[idx] = true;
                completed++;
            } else {
                currentTime++;
            }
        }

        printResults(processes, "Priority (Non-Preemptive)");
    }

    // ---------- Round Robin (Preemptive) Scheduling ----------
    public static void roundRobin(List<Process> processes, int quantum) {
        int n = processes.size();
        Queue<Process> queue = new LinkedList<>();
        processes.sort(Comparator.comparingInt(p -> p.arrivalTime));

        int currentTime = 0;
        int completed = 0;
        Set<Integer> inQueue = new HashSet<>();

        while (completed < n) {
            // Add processes that have arrived
            for (Process p : processes) {
                if (p.arrivalTime <= currentTime && !inQueue.contains(p.pid) && p.remainingTime > 0) {
                    queue.add(p);
                    inQueue.add(p.pid);
                }
            }

            if (queue.isEmpty()) {
                currentTime++;
                continue;
            }

            Process current = queue.poll();
            inQueue.remove(current.pid);

            int timeSlice = Math.min(quantum, current.remainingTime);
            current.remainingTime -= timeSlice;
            currentTime += timeSlice;

            // Add new arrivals
            for (Process p : processes) {
                if (p.arrivalTime <= currentTime && !inQueue.contains(p.pid) && p.remainingTime > 0) {
                    queue.add(p);
                    inQueue.add(p.pid);
                }
            }

            if (current.remainingTime > 0) {
                queue.add(current);
                inQueue.add(current.pid);
            } else {
                current.turnaroundTime = currentTime - current.arrivalTime;
                current.waitingTime = current.turnaroundTime - current.burstTime;
                completed++;
            }
        }

        printResults(processes, "Round Robin (Quantum = " + quantum + ")");
    }

    // ---------- Helper Method to Display Results ----------
    public static void printResults(List<Process> processes, String title) {
        System.out.println("\n--- " + title + " ---");
        System.out.println("PID\tArrival\tBurst\tPriority\tWaiting\tTurnaround");
        double totalWT = 0, totalTAT = 0;

        for (Process p : processes) {
            totalWT += p.waitingTime;
            totalTAT += p.turnaroundTime;
            System.out.println(p.pid + "\t" + p.arrivalTime + "\t" + p.burstTime + "\t" + p.priority + "\t\t"
                    + p.waitingTime + "\t" + p.turnaroundTime);
        }

        System.out.printf("Average Waiting Time: %.2f\n", totalWT / processes.size());
        System.out.printf("Average Turnaround Time: %.2f\n", totalTAT / processes.size());
    }

    // ---------- Main Method ----------
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        List<Process> processes = new ArrayList<>();

        System.out.print("Enter number of processes: ");
        int n = sc.nextInt();

        for (int i = 0; i < n; i++) {
            System.out.println("\nProcess " + (i + 1) + " details:");
            System.out.print("Burst Time: ");
            int bt = sc.nextInt();
            System.out.print("Arrival Time: ");
            int at = sc.nextInt();
            System.out.print("Priority: ");
            int pr = sc.nextInt();
            processes.add(new Process(i + 1, bt, at, pr));
        }

        // Run Priority Scheduling
        List<Process> copy1 = new ArrayList<>();
        for (Process p : processes) {
            copy1.add(new Process(p.pid, p.burstTime, p.arrivalTime, p.priority));
        }
        priorityNonPreemptive(copy1);

        // Run Round Robin Scheduling
        System.out.print("\nEnter Time Quantum for Round Robin: ");
        int quantum = sc.nextInt();

        List<Process> copy2 = new ArrayList<>();
        for (Process p : processes) {
            copy2.add(new Process(p.pid, p.burstTime, p.arrivalTime, p.priority));
        }
        roundRobin(copy2, quantum);

        sc.close();
    }
}
